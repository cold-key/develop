# 作用域和编译链接

## 命名空间

## 局部变量
- 局部变量没有链接属性标识符具有另一个名为**链接（linkage）**的属性。标识符的链接属性决定了该名称的其他声明是否引用同一对象。局部变量没有链接属性，这意味着每个声明都是唯一的对象。
- 最佳实践:在最有限的现有作用域内定义变量。

## 全局变量
- 全局变量在全局命名空间中的文件顶部、include的下方声明
- 在命名空间内声明的变量也是全局变量。
- 全局变量在程序启动时创建，在程序结束时销毁。这称为静态存储期。具有静态存储期的变量有时称为静态变量。
- 最佳实践:在命名非常量的全局变量时，请考虑使用“g”或“g_”前缀，以帮助将它们与局部变量和函数参数区分开来。但在用户定义的命名空间内定义的全局变量通常省略前缀。
- **与局部变量（默认情况下未初始化）不同，具有静态存储期的变量默认为被零初始化**
- **应完全避免使用非常量的全局变量！**

## 变量名称遮挡
- 变量名称遮挡是指在程序中一个作用域内的变量名（或标识符）隐藏（遮蔽）了外部作用域中相同名称的变量。 这会导致在遮蔽内部作用域内，无法直接访问外部作用域的变量，因为 编译器 或 解释器 将优先选择内部作用域的变量，而不是外部的。
- 最佳实践:避免变量遮挡。

## 内部链接
- 全局变量和函数标识符可以具有内部链接或外部链接属性。具有内部链接的标识符可以在单个翻译单元内看到并使用，但它不能从其他翻译单元访问（即，它不向链接器公开）。**这意味着，如果两个源文件具有具有内部链接的同名标识符，则这些标识符将被视为独立的（并且不会因具有重复定义而导致ODR冲突）。**
- 具有内部链接的全局变量有时称为内部变量。为了使非常量的全局变量成为内部变量，使用static关键字。默认情况下，Const和constexpr全局变量具有内部链接属性（因此不需要static关键字——如果使用static关键字也无额外作用）。
- static 对比 未命名的命名空间。在现代C++中，使用static关键字为标识符提供内部链接越来越不受欢迎。未命名的名称空间可以为更广泛的标识符（例如，类型标识符）提供内部链接，并且它们更适合为多个标识符提供内部链接。
- **最佳实践：当您有明确的理由不允许从其他文件访问时，将标识符设置为内部链接。最好将您不希望其他文件访问的所有标识符设置为内部链接（使用未命名的命名空间）。**

## 外部链接和变量前向声明
- 具有外部链接的标识符既可以从定义它的文件中看到，也可以从其他代码文件中使用（**通过前向声明**）。在这种意义上，**具有外部链接的标识符是真正的“全局”标识符**，因为它们可以在程序中的任何位置使用！
- 默认情况下，函数具有外部链接
- 具有外部链接的全局变量有时称为外部变量。要将全局变量设置为外部变量（因此可由其他文件访问），可以使用extern关键字执行此操作。默认情况下，非常量的全局变量是外部链接（添加extern关键字也会被忽略）。
- **关键字 extern 可以应用于全局变量、函数或模板*声明*。 它指定符号具有外部链接。**

## 在多个文件中共享全局常量（使用内联变量）
- 使用 constexpr 和命名空间：在头文件中定义全局常量，利用 constexpr 确保常量在编译时确定值，通过命名空间避免命名冲突。然而，这种方法会导致每个包含头文件的.cpp文件中都有一份常量的副本，增加了内存占用和编译时间。
- 使用外部链接属性：在.cpp文件中定义全局常量，并在头文件中声明。这样可以确保全局常量只有一份定义，**但这些常量在其他文件中被视为运行时常量，无法在需要编译时常量的上下文中使用（如数组大小或模板参数）**。
- 使用内联变量（**C++17+**）：这是目前最推荐的方法。通过在头文件中定义inline constexpr变量，可以避免重复定义问题，同时保持编译时常量的特性。它充分利用了C++17引入的内联变量特性，解决了前两种方法的痛点。**inline不会增加常量副本，唯一缺点就是在修改值之后，所有#include它的都要重新编译**
- **在C++17+版本优先使用inline，其次最好在头文件中定义常量。**

## 作用域、存储期和链接摘要
### 作用域摘要
标识符的作用域**确定可以在源代码中访问标识符的位置**。

1. 具有块（局部）作用域的变量只能从声明点访问，直到声明它们的块（包括嵌套块）的末尾。这包括：
   - 局部变量
   - 函数参数
   - 代码块中类型定义
2. 具有全局作用域的变量和函数可以从**声明点**访问，直到文件结束。这包括：
   - 全局变量
   - 函数
   - 命名空间（全局或非全局）中类型定义（例如enum和class）

### 存储期摘要
变量的存储期**决定了它的创建和销毁时间。**

1. 具有自动存储期的变量在定义点创建，并在退出它们所属的块时销毁。这包括：
   - 局部变量
   - 函数参数
2. 具有静态存储期的变量在程序开始时创建，在程序结束时销毁。这包括：
   - 全局变量
   - 静态局部变量
3. 具有动态存储期的变量由程序员请求创建和销毁。这包括：
   - 动态创建的变量

### 链接摘要
**标识符的链接属性确定标识符的多个声明是否引用同一实体（对象、函数、引用等）。**

1. 没有链接的标识符意味着该标识符仅引用其自身。这包括：
   - 局部变量
   - 代码块中类型定义（例如enum和class）
2. 具有内部链接的标识符可以在其声明的文件中的任何位置访问。这包括：
   - Static 全局变量
   - Static 函数
   - Const 全局变量
   - 在未命名的命名空间中声明的函数
   - 在未命名的命名空间中类型定义（例如enum和class）
3. 具有外部链接的标识符可以在其声明的文件或其他文件中的任何位置访问（通过前向声明）。这包括：
   - 函数
   - 非常量全局变量
   - Extern const 全局变量
   - Inline const 全局变量
如果将定义编译到多个.cpp文件中，则具有外部链接的标识符通常会导致重复定义的链接器错误（由于违反了单定义规则）。这个规则有一些例外（对于类型、模板和内联函数和变量）——在对应的课程中有相应的说明。

另请注意，默认情况下，**函数具有外部链接。可以使用static关键字将它们设置为内部链接**。

更多细节，参照[作用域、存储期和链接摘要](https://www.studycpp.cn/basic/chapter7/scope-duration-linkage/)

## using

1. using指令实际上并不会将名称导入到当前作用域中——相反，它们将名称导入外部作用域中（然而，这些名称不能从外部作用域访问——它们只能通过从using指令（或嵌套作用域）的作用域进行非限定（无前缀）查找来访问。实际效果是（在嵌套名称空间内涉及多个using指令的一些奇怪的边缘情况之外），using指令的行为就像名称已导入到当前范围中一样。为了保持简单，我们在将名称导入当前作用域的简化理解下继续。

2. using声明和using指令的作用范围:如果在块中使用using声明或using指令，则名称仅适用于该块（它遵循正常的块作用域规则）。这是一件好事，因为它减少了在该块内发生命名冲突的机会。如果在全局命名空间中使用using声明或using指令，则名称适用于文件的整个其余部分（它们具有文件范围）。

3. 一旦声明了using语句，就无法在声明它的范围内取消它或用其他using语句替换它。

## 未命名与内联的命名空间

```cpp
未命名命名空间（也称为匿名命名空间）是定义时没有名称的命名空间
namespace{
    int x {1};
    void showXValue(int x){
        std::cout << x;
    }
}

int main(){
    showXValue();
    return 0;
}
```

**在未命名命名空间中声明的所有内容都被视为父命名空间的一部分。**

这可能会使未命名的命名空间看起来毫无用处。但未命名命名空间的另一个影响是，**未命名命名空间内的所有标识符都被视为具有内部链接**，这意味着在定义未命名命名空间所在的文件外部看不到未命名名称空间的内容。对于函数，这实际上与将未命名命名空间中的所有函数定义为static函数相同。

当您有许多内容要确保它们具有内部连接时，通常会使用未命名命名空间。因为在单个未命名命名空间中集中定义此类内容，比将所有声明标记为static更容易。未命名的名称空间还将用户自定义的类型限制在本文件中，这方面没有替代的等效机制。

**内联命名空间内声明的任何内容都被视为父命名空间的一部分。然而，与未命名名称空间不同，内联名称空间不影响链接。**