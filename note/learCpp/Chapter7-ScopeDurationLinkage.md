# 作用域和编译链接

## 命名空间

## 局部变量
- 局部变量没有链接属性标识符具有另一个名为**链接（linkage）**的属性。标识符的链接属性决定了该名称的其他声明是否引用同一对象。局部变量没有链接属性，这意味着每个声明都是唯一的对象。
- 最佳实践:在最有限的现有作用域内定义变量。
## 全局变量
- 全局变量在全局命名空间中的文件顶部、include的下方声明
- 在命名空间内声明的变量也是全局变量。
- 全局变量在程序启动时创建，在程序结束时销毁。这称为静态存储期。具有静态存储期的变量有时称为静态变量。
- 最佳实践:在命名非常量的全局变量时，请考虑使用“g”或“g_”前缀，以帮助将它们与局部变量和函数参数区分开来。但在用户定义的命名空间内定义的全局变量通常省略前缀。
- **与局部变量（默认情况下未初始化）不同，具有静态存储期的变量默认为被零初始化**
- **应完全避免使用非常量的全局变量！**
## 变量名称遮挡
- 变量名称遮挡是指在程序中一个作用域内的变量名（或标识符）隐藏（遮蔽）了外部作用域中相同名称的变量。 这会导致在遮蔽内部作用域内，无法直接访问外部作用域的变量，因为 编译器 或 解释器 将优先选择内部作用域的变量，而不是外部的。
- 最佳实践:避免变量遮挡。
## 内部链接
- 全局变量和函数标识符可以具有内部链接或外部链接属性。具有内部链接的标识符可以在单个翻译单元内看到并使用，但它不能从其他翻译单元访问（即，它不向链接器公开）。**这意味着，如果两个源文件具有具有内部链接的同名标识符，则这些标识符将被视为独立的（并且不会因具有重复定义而导致ODR冲突）。**
- 具有内部链接的全局变量有时称为内部变量。为了使非常量的全局变量成为内部变量，使用static关键字。默认情况下，Const和constexpr全局变量具有内部链接属性（因此不需要static关键字——如果使用static关键字也无额外作用）。
- static 对比 未命名的命名空间。在现代C++中，使用static关键字为标识符提供内部链接越来越不受欢迎。未命名的名称空间可以为更广泛的标识符（例如，类型标识符）提供内部链接，并且它们更适合为多个标识符提供内部链接。
- **最佳实践：当您有明确的理由不允许从其他文件访问时，将标识符设置为内部链接。最好将您不希望其他文件访问的所有标识符设置为内部链接（使用未命名的命名空间）。**
## 外部链接和变量前向声明
- 具有外部链接的标识符既可以从定义它的文件中看到，也可以从其他代码文件中使用（**通过前向声明**）。在这种意义上，**具有外部链接的标识符是真正的“全局”标识符**，因为它们可以在程序中的任何位置使用！
- 默认情况下，函数具有外部链接
- 具有外部链接的全局变量有时称为外部变量。要将全局变量设置为外部变量（因此可由其他文件访问），可以使用extern关键字执行此操作。默认情况下，非常量的全局变量是外部链接（添加extern关键字也会被忽略）。
- **关键字 extern 可以应用于全局变量、函数或模板*声明*。 它指定符号具有外部链接。**
## 在多个文件中共享全局常量（使用内联变量）
- 使用 constexpr 和命名空间：在头文件中定义全局常量，利用 constexpr 确保常量在编译时确定值，通过命名空间避免命名冲突。然而，这种方法会导致每个包含头文件的.cpp文件中都有一份常量的副本，增加了内存占用和编译时间。
- 使用外部链接属性：在.cpp文件中定义全局常量，并在头文件中声明。这样可以确保全局常量只有一份定义，**但这些常量在其他文件中被视为运行时常量，无法在需要编译时常量的上下文中使用（如数组大小或模板参数）**。
- 使用内联变量（**C++17+**）：这是目前最推荐的方法。通过在头文件中定义inline constexpr变量，可以避免重复定义问题，同时保持编译时常量的特性。它充分利用了C++17引入的内联变量特性，解决了前两种方法的痛点。**inline不会增加常量副本，唯一缺点就是在修改值之后，所有#include它的都要重新编译**
- **在C++17+版本优先使用inline，其次最好在头文件中定义常量。**