# 控制流
## Constexpr if
考虑以下代码
```cpp
    constexpr int x {9};
    if(x == 9){
        std::cout << "true";
    }else{
        std::cout << "true";
    }
```
在运行时计算constexpr条件表达式是浪费的（因为结果永远不会变化）。将代码编译为永远无法执行的可执行文件也是浪费的。

C++17引入了 constexpr if 语句，该语句要求条件是常量表达式。将在**编译时计算constexpr if语句的条件表达式的结果**。如果constexpr条件的计算结果为true，则整个If-else将替换为true语句。如果constexpr条件的计算结果为false，则整个If-else将替换为false语句（如果存在else）或直接删除（如果没有else）。
```cpp
    constexpr int x {9};
    if constexpr (x == 9){
        std::cout << "true";
    }else{
        std::cout << "true";
    }
```

出于优化目的，现代编译器通常将具有常量条件的非constexpr-if语句视为constexpr-if语句。然而，这并不意味着一定会这样做。遇到具有常量条件的非constexpr-if语句，编译器可能会发出警告，建议您改用constexpr-if语句。这将确保发生编译时计算（即使禁用编译优化）。

## switch
条件必须求值为**整数类型**（请参见基本数据类型的介绍）或**枚举类型**（在未来的–无范围枚举中介绍），**或者可以转换为一个整数或枚举值**。为什么switch语句只允许整数（或枚举）类型？答案是因为switch语句被设计为高度优化。从历史上看，编译器实现switch语句的最常见方法是通过跳转表——跳转表只能处理整数值。对于那些已经熟悉数组的人来说，跳转表的工作方式与数组非常相似，使用整数值作为数组索引来直接“跳转”到结果。这比进行一系列顺序比较要有效得多。当然，编译器不必使用跳转表实现switch语句，有时它们也不需要。从技术上讲，C++没有理由不放松限制，以便也可以使用其他类型，只是还没有这样做（截至C++23）。
### Fallthrough机制
当switch表达式与case标签或可选的默认标签匹配时，执行从匹配标签之后的第一条语句开始。然后继续按顺序执行，直到发生以下终止条件之一：
- switch代码块结束
- 另一个控制流语句（通常是break或return）导致退出代码块或函数。
- 其它打断程序正常控制流的事情（操作系统杀死了对应的进程等其它原因）。

请注意，另一个case标签的存在不是这些终止条件之一——因此，如果没有中断或返回，执行将溢出到后续的case情况中。

由于很少需要有意进行fallthrough，因此许多编译器和代码分析工具将fallthrough标记为警告。可以通过注释，来告诉其它开发人员，switch的fallthrough行为是有意设计的。虽然这对其他开发人员有效，但编译器和代码分析工具不知道如何解释注释，因此不会消除警告。

为了帮助解决这个问题，C++17添加了一个名为\[[fallthrough]]的新属性。

属性是一种现代C++功能，它允许程序员向编译器提供有关代码的一些附加数据。要指定属性，请将属性名称放在双中括号之间。属性不是语句——相反，它们几乎可以在上下文相关的任何地方使用。

**同时“堆叠”多个case标签，以使所有这些case标签在之后共享相同的语句集。这不被认为是fallthrough行为，因此这里不需要使用注释或\[[fallthrough]]。**

**对于switch语句，标签后的语句都作用于switch块。不会创建隐式块。可以在case标签之前和之后声明或定义（但不能初始化）switch语句内的变量**
```cpp
    switch(x){
        case 1:
            int x {0};// 不合法，不允许初始化变量
            int y;
            y = 1;
            break;
        case 2:
            y = 2;
            int y; // eror
            break;
    }
    // error
```

## goto
在C++中，无条件跳转是通过goto语句实现的，跳转到的位置是通过使用语句标签来标识的。
```cpp
#include <iostream>
#include <cmath> // 引用 sqrt() 函数

int main()
{
    double x{};
tryAgain: // 这是标签语句
    std::cout << "Enter a non-negative number: "; 
    std::cin >> x;

    if (x < 0.0)
        goto tryAgain; // 这是goto语句

    std::cout << "The square root of " << x << " is " << std::sqrt(x) << '\n';
    return 0;
}
```

标签语句使用第三种作用域：**函数作用域**，这意味着标签在整个函数中都是可见的，甚至在其声明点之前也是可见的。goto语句及其对应的标签语句必须出现在同一函数中。

**避免goto语句（除非替代方案对代码可读性的影响明显）。**

## 提前退出程序
[learnCpp-提前退出程序-链接](https://www.studycpp.cn/basic/chapter8/halt/)
### std::exit();
在正常的main函数return时，所有局部变量和函数参数都会被销毁（通常情况）。接下来，调用一个名为std::exit()的特殊函数，并将main()函数的返回值作为参数传入。exit()执行许多清理函数。首先，销毁具有静态存储期的对象。然后，如果使用了任何文件，则执行一些文件清理动作。最后，用传递给std::exit()的参数用作状态码，将控制返回给操作系统。

std::exit()函数不清理当前函数以及调用堆栈中的**局部变量**。

**最好不要自己显示调用std::exit()**

### std::atexit()
由于std::exit()立即终止程序，因此您可能希望在终止之前手动进行一些清理。在这种情况下，清理意味着关闭数据库或网络连接、释放分配的任何内存、将信息写入日志文件等。为了帮助实现这一点，C++提供了std::atexit()函数，它允许您指定一个函数，该函数将在程序终止时通过std::exit()自动调用。**指定的函数必须是没有参数且没有返回值的函数**。最后，如果需要，可以使用std::atexit()注册多个清理函数，它们将按注册的相反顺序调用（最后注册的函数将首先调用）。

### std::terminate() 和 std::abort()
std::terminate()函数在出现未处理的异常时被调用，用于清理当前函数以及调用堆栈中的**局部变量**。
std::abort()函数在出现严重错误时被调用，用于清理当前函数以及调用堆栈中的**局部变量**。