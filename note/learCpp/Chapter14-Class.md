# 类

## 1. 成员函数
除了有成员变量之外，类类型（包括结构体、类和联合）也可以有自己的函数！属于类类型的函数称为成员函数。不是成员函数的函数被称为非成员函数，以将它们与成员函数区分开来。成员函数必须在**类类型定义内部声明，可以在类类型内部或外部定义**。提醒一下，定义也是声明，因此如果在类中定义成员函数，它将被视为声明。
```cpp
// 成员函数版本
#include <iostream>

struct Date
{
    int year {};
    int month {};
    int day {};

    void print() // 定义了成员函数 print
    {
        std::cout << year << '/' << month << '/' << day;
    }
};

int main()
{
    Date today { 2020, 10, 14 }; // 结构体聚合初始化

    today.day = 16; // 使用 (.) 来访问成员变量
    today.print();  // 使用 (.) 来访问成员函数

    return 0;
}
```

### 1.1 成员函数在类类型定义内声明
在非成员函数示例中，print() 非成员函数在Date结构体外部的全局命名空间中定义。默认情况下，它具有外部链接，因此可以从其他源文件调用它（使用适当的前向声明）。

在成员函数示例中，print() 成员函数在Date结构体定义中声明。因此 print() 被声明为Date的一部分，所以这告诉编译器print() 是一个成员函数。

在类类型定义内定义的成员函数是**隐式内联**的，因此如果类类型定义被包含在多个代码文件中，它们不会导致违反单定义规则。

### 1.2 成员变量和函数可以按任何顺序定义

对于非成员函数，可以前向声明变量或函数，以便在编译器看到完整定义之前使用它们。

**类类型的成员变量和成员函数不能显式前向声明（因为编译器总是需要查看完整的类类型定义才能正常工作）**。在正常的编译规则下，这意味着不能在定义成员之前使用它们，并且将被迫按使用顺序定义它们。那将是一种痛苦！

因此，编译器有一个巧妙的技巧：**类内的实际定义有隐式的向前声明**。

这样，在编译器编译成员变量初始值设定项和成员函数定义，它已经看到了类的所有成员的隐式声明！

### 1.3 结构体和成员函数
在C中，结构体只能有成员变量，没有成员函数。

在C++中，在设计class时，Bjarne Stroustrup花费了一些时间考虑是否应授予结构体（从C继承）具有成员函数的能力。经过考虑，决定应该这样做。

**在现代C++中，结构体具有成员函数。**

**结构体和类将具有统一的规则集（这意味着结构体可以做类可以做的一切，反之亦然）。**

**然而，结构体应该避免定义构造函数，因为这样做会使它们成为非聚合函数。**


## 2. Const类对象和Const成员函数

通过使用const关键字，类类型对象（结构体、类和联合）也可以成为const。这样的对象也必须在**创建时初始化**。一旦初始化了常量类类型对象，就**不允许任何修改它的数据成员的操作**，因为这将违反const属性。这包括**直接更改成员变量（如果它们是public的），或调用设置成员变量的成员函数**。
```cpp
struct Date
{
    int year {};
    int month {};
    int day {};
};

int main()
{
    const Date today { 2020, 10, 14 }; // const class 类型的对象

    return 0;
}
```
### 2.1 Const成员函数

```cpp
struct Date
{
    int year {};
    int month {};
    int day {};

    void print() const // 现在是个const成员函数
    {
        std::cout << year << '/' << month << '/' << day;
    }
};
```
对于高级读者：对于在类定义之外定义的成员函数，const关键字必须同时用于类定义中的函数声明和类定义之外的函数定义。我们在后续进行举例。构造函数不能设置为const，因为它们需要初始化或修改对象的成员。

**Const对象不能调用非const成员函数，可以在非常量对象上调用const成员函数。最佳实践：不（并且永远不会）修改对象状态的成员函数应成为const，以便可以在常量和非常量对象上调用它。**

## 3. 公共和私有成员以及访问说明符
C++有三种不同的访问级别：公共（public）、私有（private）和受保护（protected）。每当访问成员时，编译器都会检查该成员的访问级别，是否允许访问该成员。如果不允许访问，编译器将生成编译错误。

**默认情况下，结构体的成员是public的，类的成员是私有的。** 私有成员可以被类的其他成员访问，但不能被公共访问。**具有私有成员的类不再是聚合，因此不能再使用聚合初始化。**

### 3.1 结构体和类的访问级别最佳实践

**结构体应该完全避免访问说明符**，这意味着默认情况下所有结构体成员都是公共的。我们希望结构体是聚合，并且聚合只能具有公共成员。使用“public:”访问说明符在默认情况下是多余的，使用“private:”或“protected:”将使该结构体成为非聚合结构。

**类通常应仅具有私有（或受保护）数据成员**（通过使用默认的“private:”或“protected:”）。

**类通常具有公共成员函数**（因此这些成员函数可以在创建对象后由公共使用）。如果成员函数不打算供公众使用，则有时会将其设为私有（或受保护）。

**最佳实践：类通常应该使成员变量私有（或受保护），而成员函数公共。结构体通常应避免使用访问说明符（所有成员都将默认为public）。**

### 3.2 访问级别按类工作
C++访问级别的一个细微差别是，对成员的访问是在每个类的基础上定义的，而不是在每个对象的基础上。

成员函数可以直接访问（隐式对象的）私有成员。然而，由于访问级别是按类的，而不是按对象的，因此**成员函数还可以直接访问作用域中同一类类型的任何其他对象的私有成员**。例如：
```cpp
#include <iostream>
#include <string>
#include <string_view>

class Person
{
private:
    std::string m_name{};

public:
    void kisses(const Person& p) const
    {
        std::cout << m_name << " kisses " << p.m_name << '\n';
    }

    void setName(std::string_view name)
    {
        m_name = name;
    }
};

int main()
{
    Person joe;
    joe.setName("Joe");
    
    Person kate;
    kate.setName("Kate");

    joe.kisses(kate);

    return 0;
}
```

### 3.3 结构体和类之间的技术和实践差异
在实践中，以不同的方式使用结构体和类。

根据经验法则，在满足以下所有条件时使用结构体：
1. 有一个简单的数据集合，不能从限制访问中受益。
2. 聚合初始化已足够。
3. 没有类不变量、设置限制或清理需要。

可以在何处使用结构体的几个示例：constexpr全局程序数据、简单结构（例如int成员的简单集合，不能从私有化中受益）、用于从函数返回一组数据的结构。

否则使用类。

我们希望结构体是

## 4. 访问函数
访问函数是一个普通的公共成员函数，其任务是检索或更改私有成员变量的值。

访问函数有两种：getter和setter。Getter（有时也称为访问器）是返回私有成员变量值的public成员函数。Setter（有时也称为mutator）是设置私有成员变量值的public成员函数。

Getter通常被设置为const，因此可以在常量和非常量对象上调用它们。Setter应该是非const，因此它们需要修改数据成员。

```cpp
#include <iostream>

class Date
{
private:
    int m_year { 2020 };
    int m_month { 10 };
    int m_day { 14 };

public:
    void print()
    {
        std::cout << m_year << '/' << m_month << '/' << m_day << '\n';
    }

    int getYear() const { return m_year; }        // getter for year
    void setYear(int year) { m_year = year; }     // setter for year

    int getMonth() const  { return m_month; }     // getter for month
    void setMonth(int month) { m_month = month; } // setter for month

    int getDay() const { return m_day; }          // getter for day
    void setDay(int day) { m_day = day; }         // setter for day
};

int main()
{
    Date d{};
    d.setYear(2021);
    std::cout << "The year is: " << d.getYear() << '\n';

    return 0;
}
```

**Getter应通过值或常量值引用返回。** Getter应提供对数据的“只读”访问。因此，最佳实践是，它们应该通过值（如果制作成员的副本成本不高）或常量值引用（如果制作该成员的副本的成本很高）返回。

**优先实现行为或操作，而不是访问函数。例如，不是实现setAlive(bool)这样的setter，而是实现kill() 和 revive() 函数。**

## 5. 成员函数返回对数据成员的引用

在前面，我们讨论了函数通过引用返回数据。特别是，可以注意到，“通过引用返回的对象必须在函数返回后存在”。这意味着**不应该通过引用返回局部变量**，因为在局部变量被销毁后，引用将悬空。**通常可以通过引用返回，a. 通过引用传递的函数参数或 b. 具有静态存储期的变量（静态局部变量或全局变量）**，因为它们通常不会在函数返回后被销毁。

**按值返回数据成员可能很昂贵。** 假设有getName() 访问函数按值返回std::string m_name。虽然这是最安全的做法，但这也意味着每次调用 getName() 时都会生成m_name的昂贵副本。由于访问函数往往被大量调用，因此这通常不是最佳选择。

***成员函数还可以通过（常量）左值引用返回数据成员。且返回引用的成员函数，应返回与所返回的数据成员类型相同的引用，以避免不必要的转换。***

## 6. 数据隐藏（封装）的好处
1. 数据隐藏使类更易于使用，并降低了复杂性
2. 数据隐藏允许我们维护不变量
3. 。。。。。。。。。。。

## 7. 构造函数

