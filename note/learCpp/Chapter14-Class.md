# 类

## 1. 成员函数
除了有成员变量之外，类类型（包括结构体、类和联合）也可以有自己的函数！属于类类型的函数称为成员函数。不是成员函数的函数被称为非成员函数，以将它们与成员函数区分开来。成员函数必须在**类类型定义内部声明，可以在类类型内部或外部定义**。提醒一下，定义也是声明，因此如果在类中定义成员函数，它将被视为声明。
```cpp
// 成员函数版本
#include <iostream>

struct Date
{
    int year {};
    int month {};
    int day {};

    void print() // 定义了成员函数 print
    {
        std::cout << year << '/' << month << '/' << day;
    }
};

int main()
{
    Date today { 2020, 10, 14 }; // 结构体聚合初始化

    today.day = 16; // 使用 (.) 来访问成员变量
    today.print();  // 使用 (.) 来访问成员函数

    return 0;
}
```

### 1.1 成员函数在类类型定义内声明
在非成员函数示例中，print() 非成员函数在Date结构体外部的全局命名空间中定义。默认情况下，它具有外部链接，因此可以从其他源文件调用它（使用适当的前向声明）。

在成员函数示例中，print() 成员函数在Date结构体定义中声明。因此 print() 被声明为Date的一部分，所以这告诉编译器print() 是一个成员函数。

在类类型定义内定义的成员函数是**隐式内联**的，因此如果类类型定义被包含在多个代码文件中，它们不会导致违反单定义规则。

### 1.2 成员变量和函数可以按任何顺序定义

对于非成员函数，可以前向声明变量或函数，以便在编译器看到完整定义之前使用它们。

**类类型的成员变量和成员函数不能显式前向声明（因为编译器总是需要查看完整的类类型定义才能正常工作）**。在正常的编译规则下，这意味着不能在定义成员之前使用它们，并且将被迫按使用顺序定义它们。那将是一种痛苦！

因此，编译器有一个巧妙的技巧：**类内的实际定义有隐式的向前声明**。

这样，在编译器编译成员变量初始值设定项和成员函数定义，它已经看到了类的所有成员的隐式声明！

### 1.3 结构体和成员函数
在C中，结构体只能有成员变量，没有成员函数。

在C++中，在设计class时，Bjarne Stroustrup花费了一些时间考虑是否应授予结构体（从C继承）具有成员函数的能力。经过考虑，决定应该这样做。

**在现代C++中，结构体具有成员函数。**

**结构体和类将具有统一的规则集（这意味着结构体可以做类可以做的一切，反之亦然）。**

**然而，结构体应该避免定义构造函数，因为这样做会使它们成为非聚合函数。**


## 2. Const类对象和Const成员函数

通过使用const关键字，类类型对象（结构体、类和联合）也可以成为const。这样的对象也必须在**创建时初始化**。一旦初始化了常量类类型对象，就**不允许任何修改它的数据成员的操作**，因为这将违反const属性。这包括**直接更改成员变量（如果它们是public的），或调用设置成员变量的成员函数**。
```cpp
struct Date
{
    int year {};
    int month {};
    int day {};
};

int main()
{
    const Date today { 2020, 10, 14 }; // const class 类型的对象

    return 0;
}
```
### 2.1 Const成员函数

```cpp
struct Date
{
    int year {};
    int month {};
    int day {};

    void print() const // 现在是个const成员函数
    {
        std::cout << year << '/' << month << '/' << day;
    }
};
```
对于高级读者：对于在类定义之外定义的成员函数，const关键字必须同时用于类定义中的函数声明和类定义之外的函数定义。我们在后续进行举例。构造函数不能设置为const，因为它们需要初始化或修改对象的成员。

**Const对象不能调用非const成员函数，可以在非常量对象上调用const成员函数。最佳实践：不（并且永远不会）修改对象状态的成员函数应成为const，以便可以在常量和非常量对象上调用它。**

## 3. 公共和私有成员以及访问说明符
C++有三种不同的访问级别：公共（public）、私有（private）和受保护（protected）。每当访问成员时，编译器都会检查该成员的访问级别，是否允许访问该成员。如果不允许访问，编译器将生成编译错误。

**默认情况下，结构体的成员是public的，类的成员是私有的。** 私有成员可以被类的其他成员访问，但不能被公共访问。**具有私有成员的类不再是聚合，因此不能再使用聚合初始化。**

### 3.1 结构体和类的访问级别最佳实践

**结构体应该完全避免访问说明符**，这意味着默认情况下所有结构体成员都是公共的。我们希望结构体是聚合，并且聚合只能具有公共成员。使用“public:”访问说明符在默认情况下是多余的，使用“private:”或“protected:”将使该结构体成为非聚合结构。

**类通常应仅具有私有（或受保护）数据成员**（通过使用默认的“private:”或“protected:”）。

**类通常具有公共成员函数**（因此这些成员函数可以在创建对象后由公共使用）。如果成员函数不打算供公众使用，则有时会将其设为私有（或受保护）。

**最佳实践：类通常应该使成员变量私有（或受保护），而成员函数公共。结构体通常应避免使用访问说明符（所有成员都将默认为public）。**

### 3.2 访问级别按类工作
C++访问级别的一个细微差别是，对成员的访问是在每个类的基础上定义的，而不是在每个对象的基础上。

成员函数可以直接访问（隐式对象的）私有成员。然而，由于访问级别是按类的，而不是按对象的，因此**成员函数还可以直接访问作用域中同一类类型的任何其他对象的私有成员**。例如：
```cpp
#include <iostream>
#include <string>
#include <string_view>

class Person
{
private:
    std::string m_name{};

public:
    void kisses(const Person& p) const
    {
        std::cout << m_name << " kisses " << p.m_name << '\n';
    }

    void setName(std::string_view name)
    {
        m_name = name;
    }
};

int main()
{
    Person joe;
    joe.setName("Joe");
    
    Person kate;
    kate.setName("Kate");

    joe.kisses(kate);

    return 0;
}
```

### 3.3 结构体和类之间的技术和实践差异
在实践中，以不同的方式使用结构体和类。

根据经验法则，在满足以下所有条件时使用结构体：
1. 有一个简单的数据集合，不能从限制访问中受益。
2. 聚合初始化已足够。
3. 没有类不变量、设置限制或清理需要。

可以在何处使用结构体的几个示例：constexpr全局程序数据、简单结构（例如int成员的简单集合，不能从私有化中受益）、用于从函数返回一组数据的结构。

否则使用类。

我们希望结构体是

## 4. 访问函数
访问函数是一个普通的公共成员函数，其任务是检索或更改私有成员变量的值。

访问函数有两种：getter和setter。Getter（有时也称为访问器）是返回私有成员变量值的public成员函数。Setter（有时也称为mutator）是设置私有成员变量值的public成员函数。

Getter通常被设置为const，因此可以在常量和非常量对象上调用它们。Setter应该是非const，因此它们需要修改数据成员。

```cpp
#include <iostream>

class Date
{
private:
    int m_year { 2020 };
    int m_month { 10 };
    int m_day { 14 };

public:
    void print()
    {
        std::cout << m_year << '/' << m_month << '/' << m_day << '\n';
    }

    int getYear() const { return m_year; }        // getter for year
    void setYear(int year) { m_year = year; }     // setter for year

    int getMonth() const  { return m_month; }     // getter for month
    void setMonth(int month) { m_month = month; } // setter for month

    int getDay() const { return m_day; }          // getter for day
    void setDay(int day) { m_day = day; }         // setter for day
};

int main()
{
    Date d{};
    d.setYear(2021);
    std::cout << "The year is: " << d.getYear() << '\n';

    return 0;
}
```

**Getter应通过值或常量值引用返回。** Getter应提供对数据的“只读”访问。因此，最佳实践是，它们应该通过值（如果制作成员的副本成本不高）或常量值引用（如果制作该成员的副本的成本很高）返回。

**优先实现行为或操作，而不是访问函数。例如，不是实现setAlive(bool)这样的setter，而是实现kill() 和 revive() 函数。**

## 5. 成员函数返回对数据成员的引用

在前面，我们讨论了函数通过引用返回数据。特别是，可以注意到，“通过引用返回的对象必须在函数返回后存在”。这意味着**不应该通过引用返回局部变量**，因为在局部变量被销毁后，引用将悬空。**通常可以通过引用返回，a. 通过引用传递的函数参数或 b. 具有静态存储期的变量（静态局部变量或全局变量）**，因为它们通常不会在函数返回后被销毁。

**按值返回数据成员可能很昂贵。** 假设有getName() 访问函数按值返回std::string m_name。虽然这是最安全的做法，但这也意味着每次调用 getName() 时都会生成m_name的昂贵副本。由于访问函数往往被大量调用，因此这通常不是最佳选择。

***成员函数还可以通过（常量）左值引用返回数据成员。且返回引用的成员函数，应返回与所返回的数据成员类型相同的引用，以避免不必要的转换。***

## 6. 数据隐藏（封装）的好处
1. 数据隐藏使类更易于使用，并降低了复杂性
2. 数据隐藏允许我们维护不变量
3. 。。。。。。。。。。。TODO 

## 7. 构造函数

构造函数是一个特殊的成员函数，在创建非聚合类类型对象后会被自动调用。

定义非聚合类类型对象时，编译器会查看是否可以找到与调用方提供的初始化值（如果有）匹配的可访问构造函数。
1. 如果找到可访问的匹配构造函数，则为对象分配内存，然后调用构造函数。
2. 如果找不到可访问的匹配构造函数，则将提示编译错误。

除了确定如何创建对象之外，构造函数通常还执行两个功能：
1. 它们通常执行成员变量的初始化（通过成员初始化列表）
2. 它们可以执行其他设置功能（通过构造函数主体中的语句）。这可能包括检查初始化值、打开文件或数据库等…

在构造函数完成执行后，我们说对象已经“构造”好，对象现在应该处于一致的可用状态。

请注意，**聚合不允许具有构造函数**——因此，如果将构造函数添加到聚合中，它就不再是聚合。

**关键点**:许多新程序员对构造函数是否创建对象感到困惑。**构造函数并不创建对象——编译器在构造函数调用之前为对象进行内存分配。** 然后对未初始化的对象调用构造函数。然而，如果找不到一组初始值设定项匹配的构造函数，编译器将提示出错。因此，虽然构造函数不创建对象，但缺少匹配的构造函数将阻止创建对象。

**构造函数参数的隐式转换**:在隐式类型转换中，可以注意到编译器将在函数调用中执行参数的隐式转换（如果需要），以匹配参数为不同类型的函数定义：
```cpp
void foo(int, int)
{
}

int main()
{
    foo('a', true); // 可以匹配 foo(int, int)

    return 0;
}
```

## 8. 构造函数成员初始化列表
```cpp
#include <iostream>

class Foo
{
private:
    int m_x {};
    int m_y {};

public:
    Foo(int x, int y)
        : m_x { x }, m_y { y } // 这里是 成员初始化列表
    {
        std::cout << "Foo(" << x << ", " << y << ") constructed\n";
    }

    void print() const
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ")\n";
    }
};

int main()
{
    Foo foo{ 6, 7 };
    foo.print();

    return 0;
}
```

**所有成员初始化列表中的成员总是按照它们在类中定义的顺序进行初始化（而不是按照列表中定义的次序）。**
```cpp
#include <algorithm> // for std::max
#include <iostream>

class Foo
{
private:
    int m_x{};
    int m_y{};

public:
    Foo(int x, int y)
        : m_y{ std::max(x, y) }, m_x{ m_y } // 这一行有问题
    {
    }

    void print() const
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ")\n";
    }
};

int main()
{
    Foo foo{ 6, 7 };
    foo.print();

    return 0;
}
```
输出:Foo(-858993460, 7)

构造函数的主体通常为空。这是因为我们主要使用构造函数进行初始化，这是通过成员初始化列表完成的。如果这就是需要做的所有事情，那么不需要在构造函数的主体中使用任何语句。**构造函数体中的语句在成员初始化列表执行后执行，因此可以添加语句来执行所需的任何其他设置任务**。
```cpp
Foo(int x, int y)
{
    m_x = x; // 这是赋值，而不是初始化
    m_y = y; // 这是赋值，而不是初始化
}
```
尽管在这种简单的情况下，这将产生预期的结果，**但在需要初始化成员的情况下（例如，属性为常量或引用的数据成员），赋值将不起作用**。最佳实践:与在构造函数主体中赋值相比，优先使用成员初始化列表。

## 9. 默认构造函数和默认参数

```cpp
// 默认构造函数
Foo()
{
    std::cout << "Foo default constructed\n";
}
```

如果类类型具有默认构造函数，则值初始化和默认初始化都将调用默认构造函数。因此，对于上述示例中的Foo类这样的类，以下内容本质上是等效的：
```cpp
Foo foo{}; // 值初始化, 调用 Foo 的默认构造函数
Foo foo2;  // 默认初始化, 调用 Foo 的默认构造函数
```

**如果构造函数中的所有参数都有默认值，则构造函数是默认构造函数（因为它可以在没有参数的情况下调用）。**
```cpp
Foo(int x=0, int y=0) // 有默认参数
    : m_x { x }
    , m_y { y }
{
    std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
}
```

**构造函数是可以重载的**

**如果非聚合类类型对象没有用户声明的构造函数，编译器将生成public默认构造函数（以便类可以是值初始化的或默认初始化的）。此构造函数称为隐式默认构造函数。也可以使用=default生成显式默认构造函数。显式默认构造函数和隐式默认构造函数都会执行零初始化**
```cpp
Foo() = default; // 生成显式默认构造函数
```

## 10. 委托构造函数
```cpp
class Employee
{
private:
    std::string m_name{};
    int m_id{ 0 };

public:
    Employee(std::string_view name)
        : Employee{ name, 0 } // 委托给 Employee(std::string_view, int) 构造函数
    {
    }

    Employee(std::string_view name, int id)
        : m_name{ name }, m_id{ id } // 实际初始化成员
    {
        std::cout << "Employee " << m_name << " created\n";
    }

};
```