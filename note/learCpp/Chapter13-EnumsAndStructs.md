
## 自定义类型 豁免了ODR
允许在多个文件中有相同的自定义类型，但单个文件只能有一个。一般来说我们会将自定义类型放在头文件中，因为编译器通常需要查看完整的定义才能使用给定的类型。必须能够将完整的类型定义传播到需要它的每个代码文件。

## struct内存对齐
现代CPU通常要求特定类型的数据必须存储在地址为其大小的整数倍的位置（例如，4字节的int应存放在地址为4的倍数的位置）。
### 为什么要进行内存对齐
由于现代内存结构和处理器结构，大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度。现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。

假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作。

### 内存对齐规则
每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。

了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：

(1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。

(3) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

内存对齐只针对结构体的成员变量，不针对成员函数（成员函数不占用结构体的内存）