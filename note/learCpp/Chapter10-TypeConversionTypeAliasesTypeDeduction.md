# 类型转换、类型别名和类型推断

## 数值提升
数值提升（Numeric Promotion）是C++中的一种特殊的类型转换机制，它主要有以下特点:
1. 目的：为了让程序在不同的CPU上都能高效运行
2. 工作原理:
    - 会把较小的数据类型（比如char）自动转换为较大的数据类型（比如int或double）
    - 这种转换是自动的，编译器不会发出警告
3. 安全性:
    - 转换前后的值完全相同，只是类型变了
    - 因为较大的类型可以完整容纳较小类型的所有可能值，所以这种转换是100%安全的

数值提升规则分为两个子类别：整型提升和浮点提升。只有这些类别中列出的转换才被视为数值提升。
1. 浮点提升:
    - char -> short -> int -> long -> long long -> float -> double
2. 整型提升:
    - 有符号char或有符号short可以转换为int。
    - 如果int可以保存对应类型的整个范围，则无符号char、char8_t和unsigned short可以转换为int，否则转换为unsigned int。
    - 如果默认情况下char是有符号的，则它遵循上面的有符号char转换规则。如果默认情况下它是无符号的，则遵循上面的无符号字符转换规则。
    - bool可以转换为int，false变为0，true变为1。

并非所有扩大转换都是数值提升，一些扩展类型转换（如char到short或int到long）在C++中不被视为数值提升（它们是数字转换，后面介绍）。这是因为这样的转换无助于将较小的类型转换为可以更有效地处理的较大类型。

## 数值转换

## 窄化转换、列表初始化

- 列表初始化不允许使用窄化转换
- 当窄化转换的源值为constexpr时，编译器一定可以知道要转换的特定值。在这种情况下，编译器可以自己执行转换，然后检查值是否被完全保留。如果未能完全保留该值，编译器可能会因错误而停止编译。如果完全保留该值，则转换不会被认为是窄化的（并且编译器可以用转换的结果替换整个转换，这样替换是安全的）。

## 类型别名

```cpp
using u8 = std::uint8_t;
using i16 = std::int16_t;
using f32 = std::float32_t;
using f64 = std::float64_t;
```

类型别名的一个用途就是用来进行与平台无关的编码。

总结和结论：虽然类型别名提供了一些好处，但它们也在代码中引入了另一个需要理解的标识符。如果这没有被可读性或理解性的一些好处所抵消，那么类型别名弊大于利。利用率较低的别名，会将我们熟悉的类型名称隐藏，并且我们无法直接搜索被隐藏的类型名称。在某些情况下（例如，使用智能指针，我们将在未来的一章中介绍），模糊类型信息也可能有害于理解类型应该如何工作。由于这个原因，类型别名应该主要用于对代码可读性或代码维护有明显好处的情况。这既是一门科学，也是一门艺术。当类型别名可以在代码中的许多地方使用，而不是在较少的地方使用时，它们最有用。